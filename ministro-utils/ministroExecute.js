const Web3Utils = require('web3-utils');
const { ethGetBalance } = require('./web3');
const expectedExceptionPromise = require('./expectedExceptionPromise');
const txCheck = require('./txCheck');
const txEvents = require('./txEvents');

// this is just to know, how much chars cen we put in one line
const lineLength = 118;
const debug = 0;

/**
 * @dev Idea for this function is to be called from test/ministro-contracts/*
 * when transaction needs to be made.
 *
 */
module.exports = function ministroExecute() {
  const app = {};
  let txAttr = {};
  const txAttrSaved = {};

  let tx;
  let events;
  let result;

  app.instance = null;


  // this function is called each time you use `getTxAttr()`,
  // if you want values to be saves permanently
  // you can use `set...Var()` functions
  app.resetTxAttr = () => {
    txAttr = {
      from: Web3Utils.randomHex(20),
      gas: 6700000,
    };
  };

  app.setGasVar = (_gas) => {
    txAttrSaved.gas = _gas;
  };

  app.setInstanceVar = (i) => {
    app.instance = i;
  };

  app.setFromVar = async (_from) => {
    let balance;
    txAttrSaved.from = _from;

    try {
      balance = await ethGetBalance(_from);
    } catch (e) {
      console.log('errors', e);
    }

    balance = parseFloat(web3.fromWei(balance.toString(10), 'ether'));

    process.stderr.write(`${' '.repeat(lineLength)}\r`);
    if (debug) console.log('[ministroExecute] new `txAttr.from` balance', balance, 'ETH');
  };

  // @param _txAttr - (optional) can be empty or can be object with transaction parameters like:
  // from, gas etc.
  // @return object with default transaction parameters overridden by values from _txAttr
  app.getTxAttr = (_txAttr) => {
    app.resetTxAttr();

    Object.keys(txAttrSaved).forEach((k) => {
      txAttr[k] = txAttrSaved[k];
    });

    // do we have saved values?
    if (typeof _txAttr === 'object') {
      Object.keys(_txAttr).forEach((k) => {
        txAttr[k] = _txAttr[k];
      });
    }

    return txAttr;
  };

  /**
     * this function should be used for executing transactions
     *
     * @param _action - required - promise action, that should be executed eg:
     * let action = () => this._instance.setOwner(_newOwner, _txAttr)
     */
  app.executeAction = async (_action, _txAttr, _logCount, _eventWanted, _expectThrow) => {
    if (_expectThrow) {
      result = await expectedExceptionPromise(_action, _txAttr.gas);
    } else {
      try {
        tx = await _action();
        await txCheck(tx, _logCount, _action.toString());
        events = txEvents(tx.logs, _eventWanted, _logCount);
      } catch (e) {
        if ((`${e}`).indexOf('account not recognized') > -1) {
          assert.isTrue(false, `Check if msg.sender exists and its not generated by random numbers: ${e.message}`);
        } else {
          // console.log(_tx)
          // console.log(_receipt)
          throw e;
        }
      }
    }

    return _expectThrow ? result : events;
  };

  return app;
};
